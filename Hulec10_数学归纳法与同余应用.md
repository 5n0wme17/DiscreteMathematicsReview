 # Hulec10 - 数学归纳法与同余应用

## 线性同余

形式为ax≡b (mod m)的同余，其中m是正整数，a和b是整数，x是变量，称为线性同余。线性同余ax≡b (mod m)的解是所有满足该同余的整数x。

线性同余系统自古就已被研究。大约1500年前，中国数学家孙子问："物不知数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？"

## 模逆

整数ā使得āa≡1 (mod m)被称为a模m的逆。求解线性同余的一种方法使用逆ā（如果存在）。从ax≡b (mod m)，得出āax≡āb (mod m)，然后x≡āb (mod m)。

a模m的逆何时存在？

## 模m的逆

**定理** 如果a和m是互质的整数且m>1，那么a模m的逆存在。此外，逆模m是唯一的。

**证明**. 由于gcd(a,m)=1，存在整数s和t使得sa+tm=1。因此sa+tm≡1 (mod m)。由于tm≡0 (mod m)，得出sa≡1 (mod m)。这意味着s是a模m的逆。

如何证明逆的唯一性？

## 如何找到逆？

使用扩展欧几里得算法

**示例**. 找到101模4620的逆。

## 使用逆求解同余

通过将同余ax≡b (mod m)两边乘以ā来求解。

**示例**. 同余3x≡4 (mod 7)的解是什么？
**解**: 我们发现-2是3模7的逆。将同余两边乘以-2，我们有x≡-8≡6 (mod 7)。

## 中国剩余定理

大约1500年前，中国数学家孙子问："物不知数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？"
x≡2 (mod 3)
x≡3 (mod 5)
x≡2 (mod 7)

## 中国剩余定理

**定理**（中国剩余定理）设m₁,m₂,...,mₙ是两两互质的正整数，大于1，a₁,a₂,...,aₙ是任意整数。那么系统
x≡a₁ (mod m₁)
x≡a₂ (mod m₂)
···
x≡aₙ (mod mₙ)
有一个模m=m₁m₂···mₙ的唯一解。

## 中国剩余定理

**证明** 设Mₖ=m/mₖ对于k=1,2,...,n且m=m₁m₂···mₙ。由于gcd(mₖ,Mₖ)=1，存在整数yₖ，Mₖ模mₖ的逆，使得Mₖyₖ≡1 (mod mₙ)。设x=a₁M₁y₁+a₂M₂y₂+···aₙMₙyₙ。可以检查x是n个同余的解。

如何证明模m的解的唯一性？

## 中国剩余定理

**示例**
x≡2 (mod 3)
x≡3 (mod 5)
x≡2 (mod 7)
设m=3·5·7=105, M₁=m/3=35, M₂=m/5=21, M₃=m/7=15。
35·2≡1 (mod 3)
21≡1 (mod 5)
15≡1 (mod 7)
y₁=2
y₂=1
y₃=1
x=2·35·2+3·21·1+2·15·1≡233≡23 (mod 105)

## 费马小定理

**定理**（费马小定理）：设p是素数，x是整数使得x≢0 mod p。那么xᵖ⁻¹≡1 (mod p)。

**示例**: 求7²²² (mod 11)
7²²² = 7²²·¹⁰⁺² = (7¹⁰)²²·7² = 1²²·49 ≡ 5 (mod 11)

**问题**: 如何证明费马小定理？
{1,2,...,p-1} = {x,2x,...,x(p-1) (mod p)}

## 数学归纳法

我们通过回顾最小反例证明来尝试理解它真正在做什么。这引导我们将反例证明的间接证明转化为直接证明。这种直接证明技术将是归纳法。我们通过区分弱数学归纳法原理和强数学归纳法原理来结束。强原理实际上可以从弱原理推导出来。

## 最小反例证明法

陈述P(n)对所有n=0,1,2,...为真。我们通过以下方式证明这一点：
(i) 假设存在反例，即存在某个n>0使得P(n)为假
(ii) 设m>0是使得P(n)为假的最小值
(iii) 然后使用对所有0≤m'<m，P(m')为真的事实来证明P(m)为真，与m的选择矛盾。矛盾！

## 示例1

使用最小反例证明法证明，∀n∈ℕ，(∗) 0+1+2+3+···+n = n(n+1)/2

- 假设(∗)不总是为真
- 那么必须存在最小的n∈ℕ使得(∗)对n不成立
- 对于任何非负整数i<n，1+2+···+i = i(i+1)/2
- 由于0=0·1/2，(∗)对n=0成立
- 最小反例n大于0

## 示例1

我们现在有(i)最小反例n大于0，且(ii)(∗)对n-1成立
- 将n-1代入i得到1+2+···+n-1 = (n-1)n/2
- 两边加上n得到1+2+···+n-1+n = (n-1)n/2 + n = n(n+1)/2
- 因此，n不是反例。矛盾！
- 所以，(∗)对所有正整数n成立

## 示例1

我们必须证明什么蕴含关系？关键步骤是证明P(n-1)→P(n)，其中P(n)是陈述1+2+···+n = n(n+1)/2

## 示例2

使用最小反例证明法证明，∀n∈ℕ，2ⁿ⁺¹ ≥ n²+2。

设P(n) – 2ⁿ⁺¹ ≥ n²+2。我们首先假设陈述∀n∈ℕ P(n)为假。当全称量词为假时，必须存在某个n使得它为假。设n是使得2ⁿ⁺¹ ≱ n²+2的最小非负整数。

## 示例2

设n是使得2ⁿ⁺¹ ≱ n²+2的最小非负整数。这意味着，对于所有i∈ℕ且i<n，2ⁱ⁺¹ ≥ i²+2。

由于2⁰⁺¹ ≥ 0²+2，我们知道n>0。因此，n-1是小于n的非负整数。然后设i=n-1得到2⁽ⁿ⁻¹⁾⁺¹ ≥ (n-1)²+2。或(∗) 2ⁿ ≥ n²-2n+1+2 = n²-2n+3

## 示例2

设n是使得2ⁿ⁺¹ ≱ n²+2的最小非负整数。我们现在已知2ⁿ ≥ n²-2n+3。(∗)

两边乘以2，得到2ⁿ⁺¹ = 2·2ⁿ ≥ 2·(n²-2n+3) = 2n²-4n+6。

为了得到矛盾，我们想将右边转换为n²+2加上一个额外的非负项。因此，我们写2ⁿ⁺¹ ≥ 2n²-4n+6 = (n²+2)+(n²-4n+4) = n²+2+(n-2)² ≥ n²+2。矛盾！

## 示例2

设P(n) – 2ⁿ⁺¹ ≥ n²+2
我们刚刚证明了：
(a) P(0)为真
(b) 如果n>0，那么P(n-1)→P(n)
- 假设存在某个n使得P(n)为假(∗)
- 设n为最小反例
- 那么，从(a)得n>0，所以P(n-1)为真
- 因此，从(b)，使用直接推理，P(n)为真
- 这与(∗)矛盾。
- 所以，P(n)对所有n∈ℕ为真

## 示例2

我们真正做了什么？设P(n) – 2ⁿ⁺¹ ≥ n²+2
我们刚刚证明了：
(a) P(0)为真
(b) 如果n>0，那么P(n-1)→P(n)
然后我们使用最小反例证明法推导出P(n)对所有n∈ℕ为真。这是一个间接证明。是否可能直接证明这个事实？由于P(n-1)→P(n)，我们看到P(0)蕴含P(1)，P(1)蕴含P(2)，...

## 数学归纳法原理

良序原理允许我们假设任何非负整数集合都有最小元素，允许我们使用最小反例。这实际上等价于数学归纳法原理。

**原理**（弱数学归纳法原理）
(a) 如果陈述P(b)为真
(b) 陈述P(n-1)→P(n)对所有n>b为真
那么P(n)对所有整数n≥b为真

## 数学归纳法原理

良序原理允许我们假设任何非负整数集合都有最小元素，允许我们使用最小反例。这实际上等价于数学归纳法原理。

**原理**（弱数学归纳法原理）
(a) 如果陈述P(b)为真
(b) 陈述P(n-1)→P(n)对所有n>b为真
那么P(n)对所有整数n≥b为真

(a) – 基础步骤
(b) – 归纳步骤
归纳假设
归纳结论

## 归纳法证明

∀n≥0，2ⁿ⁺¹ ≥ n²+2
设P(n) – 2ⁿ⁺¹ ≥ n²+2

(i) 注意对于n=0，2⁰⁺¹=2≥2=0²+2 – P(0)
(ii) 假设n>0且2ⁿ ≥ (n-1)²+2 (∗)
2ⁿ⁺¹ ≥ 2(n-1)²+4 = (n²+2)+(n²-4n+4) = n²+2+(n-2)² ≥ n²+2

因此，我们刚刚证明了对于n>0，P(n-1)→P(n)。通过数学归纳法，∀n>0，2ⁿ⁺¹ ≥ n²+2。

## 归纳法证明

∀n≥2，2ⁿ⁺¹ ≥ n²+3
设P(n) – 2ⁿ⁺¹ ≥ n²+3

(i) 注意对于n=2，2²⁺¹=8≥7=2²+3 – P(2)
(ii) 假设n>2且2ⁿ ≥ (n-1)²+3 (∗)
2ⁿ⁺¹ ≥ 2(n-1)²+6 = n²+3+n²-4n+4+1 = n²+3+(n-2)²+1 > n²+3

因此，我们刚刚证明了对于n>2，P(n-1)→P(n)。通过数学归纳法，∀n>2，2ⁿ⁺¹ ≥ n²+3。

## 归纳法证明

∀n≥2，2ⁿ⁺¹ ≥ n²+3
设P(n) – 2ⁿ⁺¹ ≥ n²+3

(i) 注意对于n=2，2²⁺¹=8≥7=2²+3 – P(2)
(ii) 假设n>2且2ⁿ ≥ (n-1)²+3 (∗)
2ⁿ⁺¹ ≥ 2(n-1)²+6 = n²+3+n²-4n+4+1 = n²+3+(n-2)²+1 > n²+3

因此，我们刚刚证明了对于n>2，P(n-1)→P(n)。通过数学归纳法，∀n>2，2ⁿ⁺¹ ≥ n²+3。

基础步骤
归纳假设
归纳步骤
归纳结论

## 归纳法的另一种形式

我们可能有另一种形式的直接证明如下：
- 首先假设我们有P(0)的证明
- 接下来假设我们有证明，∀k>0，P(0)∧P(1)∧P(2)∧···∧P(k-1)→P(k)
- 那么，P(0)蕴含P(1)
P(0)∧P(1)蕴含P(2)
P(0)∧P(1)∧P(2)蕴含P(3)
...
- 迭代给出对所有n的P(n)的证明

## 强归纳法原理

**原理**（强数学归纳法原理）
(a) 如果陈述P(b)为真
(b) 对所有n>b，陈述P(b)∧P(b+1)∧···∧P(n-1)→P(n)为真。
那么P(n)对所有整数n≥b为真。

## 示例

证明每个正整数是素数的幂或素数幂的乘积。
- 基础步骤：1是素数的幂，1=2⁰
- 归纳假设：假设每个小于n的数是素数的幂或素数幂的乘积。
- 那么，如果n不是素数幂，它是两个较小数的乘积，每个数根据归纳假设是素数的幂或素数幂的乘积。
- 因此，通过强数学归纳法原理，每个正整数是素数的幂或素数幂的乘积。

## 数学归纳法

在实践中，我们通常不明确区分弱形式和强形式。实际上，它们是等价的，因为弱形式是强形式的特例，而强形式可以从弱形式推导出来。

## 总结

典型的数学归纳法证明，显示陈述P(n)对所有整数n≥b为真，包括三个步骤：
1. 我们证明P(b)为真。– 基础步骤
2. 然后，∀n>b，我们证明要么(∗) P(n-1)→P(n) 要么(∗∗) P(b)∧P(b+1)∧···∧P(n-1)→P(n)
我们需要做出P(n-1)或P(b)∧P(b+1)∧···∧P(n-1)的归纳假设。然后我们使用(∗)或(∗∗)推导出P(n)。
3. 我们基于数学归纳法原理得出结论，P(n)对所有n≥b为真。

## 下节课内容
- 递推关系

## 相关知识点总结
- [[数论与同余]] - 数论与同余知识分块总结
- [[离散数学总览]] - 离散数学整体概述
