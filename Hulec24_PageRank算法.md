# Hulec24 - PageRank算法

## PageRank背景

**网络作为有向图**：
- 节点：网页
- 边：超链接

**问题**：并非所有网页都同样"重要"
- www.huyanqing.com vs. www.sustech.edu.cn
- 网络图节点连通性存在巨大差异

**目标**：通过链接结构对页面进行排名

## PageRank简介

**PageRank** 是 Google 搜索用于在其搜索引擎结果中对网页进行排名的算法。PageRank 以 Google 创始人之一 Larry Page 的名字命名。PageRank 是一种衡量网站页面重要性的方法。

**核心思想**：链接即投票
- 页面如果有更多链接则更重要
- 入链？出链？
- 将入链视为投票：
  - www.sustech.edu.cn 有 30000 个入链
  - www.huyanqing.com 有 1 个入链
- 所有入链都相等吗？
  - 来自重要页面的链接计数更多
  - 递归问题！

## PageRank流方程

**每个链接的投票与其源页面的重要性成正比**

如果页面 j 具有重要性 r_j 且有 n 个出链，则每个链接获得 r_j / n 票

页面 j 自身的重要性是其入链上投票的总和

**流方程**：
r_j = ∑_{i→j} r_i / d_i
其中 d_i 是节点 i 的出度

## 随机邻接矩阵

**随机邻接矩阵 M**
- 设页面 i 有 d_i 个出链
- 如果 i → j，则 M_ji = 1/d_i，否则 M_ji = 0
- M 是列随机矩阵
- 列和为 1

**排名向量 r**：每个页面有一个条目的向量
- r_i 是页面 i 的重要性分数
- ∑_i r_i = 1

流方程可以写为：r = M · r

## 幂迭代算法

**幂迭代**：寻找主特征向量的方法
- 假设有 N 个网页
- 初始化：r^(0) = [1/N, ..., 1/N]^T
- 迭代：r^(t+1) = M · r^(t)
- 当 |r^(t+1) - r^(t)|_1 < ε 时停止

|x|_1 = ∑_{1≤i≤N} |x_i| 是 L1 范数
也可以使用其他向量范数，例如欧几里得范数

## 幂迭代示例

**示例**：
ry = ry/2 + ra/2
ra = ry/2 + rm  
rm = ra/2

迭代过程：
ry: 1/3 → 1/3 → 5/12 → 9/24 → 6/15
ra: 1/3 → 3/6 → 1/3 → 11/24 → 6/15
rm: 1/3 → 1/6 → 3/12 → 1/6 → 3/15

## 幂迭代收敛性

**幂迭代**：寻找主特征向量的方法
r^(1) = M · r^(0)
r^(2) = M · r^(1) = M^2 · r^(0)
r^(k) = M · r^(k-1) = M^k · r^(0)

**断言**：序列 M · r^(0), M^2 · r^(0), ..., M^k · r^(0), ... 接近 M 的主特征向量

## PageRank方程

**PageRank方程** [Brin-Page, '98]
r_j = β ∑_{i→j} r_i / d_i + (1-β) / N

**Google矩阵 A**：
A = β M + (1-β) [1/N]_{N×N}

我们有递归问题：r = A · r
幂方法仍然有效！

在实践中 β = 0.8, 0.9

## 随机跳转机制

**随机跳转等价于**：
- 从 i 到每个其他页面添加跳转链接，并将转移概率设置为 (1-β)/N
- 将跟随每个出链的概率从 1/d_i 减少到 β/d_i
- 等价：对每个页面征收其分数的一部分 (1-β) 并均匀重新分配

## 矩阵表示

r = β M · r + (1-β)/N [1]_N
其中 [1]_N 是长度为 N 且所有条目为 1 的向量

M 是稀疏矩阵！（没有死端）
每个节点约 10 个链接，约 10N 个条目

在每次迭代中，我们需要：
- 计算 r_new = β M · r_old
- 向 r_new 中的每个条目添加常数值 (1-β)/N
- 如果 M 包含死端，则 ∑_j r_j^{new} < 1 并且我们还必须重新归一化 r_new 使其和为 1

## PageRank算法

**输入**：图 G 和参数 β
- 有向图 G（可以有蜘蛛陷阱和死端）
- 参数 β

**输出**：PageRank向量 r^*
- 设置：r_old = 1/N
- 重复直到收敛：∑_j |r_j^{new} - r_j^{old}| < ε
- ∀j: r'_j = ∑_{i→j} β r_i / d_i
  - r'_j = 0 如果 j 的入度为 0
- 现在重新插入泄漏的 PageRank：
  ∀j: r_j^{new} = r'_j + (1 - S)/N
  其中 S = ∑_j r'_j

## 大规模计算优化

**编码稀疏矩阵**仅使用非零条目
- 空间大致与链接数成正比
- 假设 10N，或 4*10*10亿 = 40GB
- 仍然不适合内存，但适合磁盘

**假设有足够 RAM 将 r_new 放入内存**
- 将 r_old 和矩阵 M 存储在磁盘上
- 幂迭代的 1 步是：
  - 初始化 r_new 的所有条目 = (1-β)/N
  - 对于每个页面 i（出度为 d_i）：
    - 读入内存：i, d_i, dest1, ..., dest_d_i, r_old(i)
    - 对于 j = 1...d_i：
      - r_new(dest_j) += β r_old(i) / d_i

## 分块优化

**将 r_new 分成 k 个适合内存的块**
- 为每个块扫描一次 M 和 r_old
- 总成本：k(|M| + |r|) + |r| = k|M| + (k+1)|r|

**将 M 分成条带**
- 每个条带仅包含 r_new 相应块中的目标节点
- 成本：|M|(1+e) + (k+1)|r|

## PageRank局限性

**衡量页面的通用流行度**
- 对特定主题的权威有偏见
- 解决方案：主题特定 PageRank

**使用单一的重要性度量**
- 其他重要性模型
- 解决方案：Hubs-and-Authorities

**容易受到链接垃圾的影响**
- 创建人工链接拓扑以提升页面排名
- 解决方案：TrustRank

## 相关知识点总结
- [[图论与关系]] - 图论与关系知识分块总结
- [[离散数学总览]] - 离散数学整体概述
