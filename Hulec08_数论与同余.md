# Hulec08 - 数论与同余

## 整除性

如果a和b是整数且a≠0，我们说a整除b，如果存在整数c使得b=ac，或者等价地b/a是整数。在这种情况下，我们说a是b的因子或除数，b是a的倍数。（我们使用符号a|b，a∤b）

**示例**
- 4|24
- 3∤7

## 整除性

所有能被d>0整除的整数可以枚举为：..., -kd, ..., -2d, -d, 0, d, 2d, ..., kd, ...

**问题**: 设n和d是两个正整数。不超过n的正整数中有多少个能被d整除？
**答案**: 计算满足0<kd≤n的整数个数。因此，有⌊n/d⌋个这样的正整数。

## 整除性性质

设a,b,c是整数。那么以下成立：
(i) 如果a|b且a|c，那么a|(b+c)
(ii) 如果a|b，那么对于所有整数c，a|bc
(iii) 如果a|b且b|c，那么a|c

**证明**.

## 整除性推论

如果a,b,c是整数，其中a≠0，使得a|b且a|c，那么当m和n是整数时，a|(mb+nc)

**证明**. 根据性质的(ii)部分和(i)部分。

## 除法算法

如果a是整数且d是正整数，那么存在唯一的整数q和r，满足0≤r<d，使得a=dq+r。在这种情况下，d称为除数，a称为被除数，q称为商，r称为余数。在这种情况下，我们使用符号q=a div d和r=a mod d。

## 同余关系

如果a和b是整数且m是正整数，那么a模m同余于b，如果m整除a-b，记作a≡b (mod m)。这称为同余，m是其模数。

**示例**
- 15≡3 (mod 6)
- -1≡11 (mod 6)

## 更多关于同余

设m是正整数。整数a和b模m同余当且仅当存在整数k使得a=b+km。

**证明**. "仅当"部分 "当"部分

## (mod m) 和 mod m 符号

a≡b (mod m) 和 a mod m = b 是不同的。
- a≡b (mod m) 是整数集上的关系
- 在 a mod m = b 中，符号 mod 表示函数

设a和b是整数，m是正整数。那么a≡b mod m当且仅当a mod m = b mod m

**证明**.

## 和与积的同余

**证明**. 设m是正整数。如果a≡b (mod m)且c≡d (mod m)，那么a+c≡b+d (mod m)且ac≡bd (mod m)

## 同余的代数操作

如果a≡b mod m，那么
- c·a≡c·b (mod m)?
- c+a≡c+b (mod m)?
- a/c≡b/c (mod m)?

14≡8 (mod 6) 但 7≢4 (mod 6)

## 计算mod函数

**推论** 设m是正整数，a和b是整数。那么
(a+b) mod m = ((a mod m) + (b mod m)) mod m
ab mod m = ((a mod m)(b mod m)) mod m

**证明**.

## 模m算术

设Zₘ是非负整数小于m的集合：{0,1,...,m-1}。
+ₘ: a +ₘ b = (a+b) mod m
·ₘ: a ·ₘ b = ab mod m

**示例**
- 7 +₁₁ 9 = ?
- 7 ·₁₁ 9 = ?

## 模m算术

**封闭性**: 如果a,b∈Zₘ，那么a+ₘb, a·ₘb∈Zₘ
**结合律**: 如果a,b,c∈Zₘ，那么(a+ₘb)+ₘc = a+ₘ(b+ₘc) 且 (a·ₘb)·ₘc = a·ₘ(b·ₘc)
**分配律**: 如果a,b,c∈Zₘ，那么a·ₘ(b+ₘc) = (a·ₘb)+ₘ(a·ₘc) 且 (a+ₘb)·ₘc = (a·ₘc)+ₘ(b·ₘc)
**单位元**: a+ₘ0 = a 且 a·ₘ1 = a
**加法逆元**: 如果a≠0且a∈Zₘ，那么m-a是a模m的加法逆元
**交换律**: 如果a,b∈Zₘ，那么a+ₘb = b+ₘa

## 整数的表示

我们可以使用十进制（基10）或二进制或八进制或十六进制或其他符号来表示整数。

设b>1是整数。那么如果n是正整数，它可以唯一地表示为形式n = aₖbᵏ + aₖ₋₁bᵏ⁻¹ + ··· + a₁b + a₀，其中k是非负的，aᵢ's是小于b的非负整数。n的表示称为n的基b展开，记作(aₖaₖ₋₁...a₁a₀)₆。

## 基b展开

获得十进制展开很容易。

**示例**
- (101011111)₂ = 2⁸ + 2⁶ + 2⁴ + 2³ + 2² + 2¹ + 2⁰ = 351
- (7016)₈ = 7·8³ + 1·8 + 6 = 3598

二进制、八进制、十六进制展开之间的转换很容易。

**示例**
- (101011111)₂ = (101 011 111) = (537)₈
- (7016)₈ = (111 000 001 110)₂ = (1110 0000 1110)₂ = (E0E)₁₆

## 基b展开

n = aₖbᵏ + aₖ₋₁bᵏ⁻¹ + aₖ₋₂bᵏ⁻² + ··· + a₂b² + a₁b + a₀
= b(aₖbᵏ⁻¹ + aₖ₋₁bᵏ⁻² + aₖ₋₂bᵏ⁻³ + ··· + a₂b + a₁) + a₀
= b(b(aₖbᵏ⁻² + aₖ₋₁bᵏ⁻³ + aₖ₋₂bᵏ⁻⁴ + ··· + a₂) + a₁) + a₀
= ···

要构造整数n的基b展开：
- 将n除以b得到n = bq₀ + a₀，其中0 ≤ a₀ < b
- 余数a₀是n的基b展开中最右边的数字。然后将q₀除以b得到q₀ = bq₁ + a₁，其中0 ≤ a₁ < b
- a₁是从右边数的第二个数字。继续依次将商除以b，直到商为0

## 算法：构造基b展开

## 示例
(12345)₁₀ = (30071)₈
12345 = 8·1543 + 1
1543 = 8·192 + 7
192 = 8·24 + 0
24 = 8·3 + 0
3 = 8·0 + 3

## 整数的二进制加法
a = (aₙ₋₁aₙ₋₂...a₁a₀)₂, b = (bₙ₋₁bₙ₋₂...b₁b₀)₂
O(n)位加法

## 算法：整数的二进制乘法
a = (aₙ₋₁aₙ₋₂...a₁a₀)₂, b = (bₙ₋₁bₙ₋₂...b₁b₀)₂
ab = a(b₀2⁰ + b₁2¹ + ··· + bₙ₋₁2ⁿ⁻¹)
= a(b₀2⁰) + a(b₁2¹) + ··· + a(bₙ₋₁2ⁿ⁻¹)
O(n²)移位和O(n²)位加法

## 算法：二进制模幂运算
依次找到b mod m, b² mod m, b⁴ mod m, ..., b²ᵏ⁻¹ mod m，并将aⱼ=1的项b²ʲ相乘。
bⁿ = b^(aₖ₋₁·2ᵏ⁻¹ + ··· + a₁·2 + a₀) = b^(aₖ₋₁·2ᵏ⁻¹)···b^(a₁·2)·b^(a₀)
O((log m)² log n)位操作

## 素数

大于1且只能被1和自身整除的正整数p称为素数。大于1且不是素数的正整数称为合数。

**算术基本定理**: 每个大于1的整数可以唯一地写成一个素数或两个或多个素数的乘积，其中素因子按非递减顺序书写。

## 素数和合数

如何确定一个数是素数还是合数？

**方法1**: 测试每个数x<n是否能整除n。
**方法2**: 测试每个素数x<n是否能整除n。
**方法3**: 测试每个素数x≤√n是否能整除n。

## 素数和合数

如果n是合数，那么n有一个素因子小于或等于√n。

**证明**:
- 如果n是合数，那么根据定义，它有一个正整数因子a满足1<a<n。这意味着n=ab，其中b是大于1的整数。
- 假设a>√n且b>√n。那么ab>n，矛盾。所以要么a≤√n，要么b≤√n。
- 因此，n有一个小于√n的因子。
- 根据算术基本定理，这个因子要么是素数，要么是素数的乘积。在任何情况下，n都有一个小于√n的素因子。

## 素数

有无穷多个素数。

**证明**（反证法）

## 最大公约数（GCD）

设a和b是整数，不全为0。最大的整数d使得d|a且d|b称为a和b的最大公约数，记作gcd(a,b)。如果a和b的最大公约数是1，则称整数a和b互质。

找到gcd的系统方法是因式分解。设a = p₁^a₁ p₂^a₂ ··· pₙ^aₙ 且 b = p₁^b₁ p₂^b₂ ··· pₙ^bₙ。那么gcd(a,b) = p₁^min(a₁,b₁) p₂^min(a₂,b₂) ··· pₙ^min(aₙ,bₙ)

## 最小公倍数（LCM）

设a和b是整数。a和b的最小公倍数是能被a和b整除的最小正整数，记作lcm(a,b)。

我们也可以使用因式分解来找到lcm。设a = p₁^a₁ p₂^a₂ ··· pₙ^aₙ 且 b = p₁^b₁ p₂^b₂ ··· pₙ^bₙ。那么lcm(a,b) = p₁^max(a₁,b₁) p₂^max(a₂,b₂) ··· pₙ^max(aₙ,bₙ)

## 欧几里得算法

因式分解可能繁琐且耗时，因为我们需要找到两个整数的所有因子。幸运的是，我们有一个有效的算法，称为欧几里得算法。这个算法自古希腊数学家欧几里得以来就已知。

## 欧几里得算法

对于两个整数287和91，我们想找到gcd(287,91)。
步骤1: 287 = 91·3 + 14
步骤2: 91 = 14·6 + 7
步骤3: 14 = 7·2 + 0
gcd(287,91) = gcd(91,14) = gcd(14,7) = 7

## 欧几里得算法

欧几里得算法的伪代码

找到gcd(a,b)所需的除法次数是O(log b)，其中a≥b。（这将在后面证明。）

## 欧几里得算法的正确性

**引理** 设a=bq+r，其中a,b,q和r是整数。那么gcd(a,b)=gcd(b,r)。

**证明**:
- 假设d|a且d|b。那么d也整除a-bq=r。因此，a和b的任何公约数也必须是b和r的公约数。
- 假设d|b且d|r。那么d也整除bq+r=a。因此，b和r的任何公约数也必须是a和b的公约数。
- 因此，gcd(a,b)=gcd(b,r)。

## 欧几里得算法的正确性

假设a和b是正整数且a≥b。设r₀=a且r₁=b。
gcd(a,b)=gcd(r₀,r₁)=···=gcd(rₙ₋₁,rₙ)=gcd(rₙ,0)=rₙ

## GCD作为线性组合

**贝祖定理** 如果a和b是正整数，那么存在整数s和t使得gcd(a,b)=sa+tb。这称为贝祖恒等式。

我们可以使用扩展欧几里得算法来找到贝祖恒等式。

**示例**: 将1表示为503和286的线性组合。
503 = 1·286 + 217
286 = 1·217 + 69
217 = 3·69 + 10
69 = 6·10 + 9
10 = 1·9 + 1
1 = 10 - 1·9 = 7·10 - 1·69 = 7·217 - 22·69 = 29·217 - 22·286 = 29·503 - 51·286

## 贝祖定理的推论

如果a,b,c是正整数使得gcd(a,b)=1且a|bc，那么a|c。

**证明**. 由于gcd(a,b)=1，根据贝祖定理存在s和t使得1=sa+tb。这产生c=sac+tbc。由于a|bc，我们有a|tbc，然后a|(sac+tbc)=c。

如果p是素数且p|a₁a₂···aₙ，那么p|aᵢ对于某个i。

**证明**. 通过归纳法。将在后面给出。

## 素数分解的唯一性

我们证明正整数n的素数分解（其中素数按非递减顺序排列）是唯一的。

**证明**.（反证法）假设正整数n可以以两种不同的方式写成素数的乘积：n=p₁p₂···pₛ和n=q₁q₂···qₜ
从分解中移除所有公共素数得到pᵢ₁pᵢ₂···pᵢᵤ=qⱼ₁qⱼ₂···qⱼᵥ
然后pᵢ₁整除某个qⱼₖ，与pᵢ₁和qⱼₖ是不同的素数的假设矛盾。

## 同余除以整数

**定理** 设m是正整数，a,b,c是整数。如果ac≡bc (mod m)且gcd(c,m)=1，那么a≡b (mod m)。

**证明**. 由于ac≡bc (mod m)，我们有m|ac-bc=c(a-b)。因为gcd(c,m)=1，所以m|a-b。

## 梅森素数

形式为2ᵖ-1的素数，其中p是素数。
- 2²-1=3, 2³-1=7, 2⁵-1=37, 2⁷-1=127是梅森素数。
- 2¹¹-1=2047=23·89不是梅森素数。
- 已知的最大素数是梅森素数。

http://www.mersenne.org/

## 关于素数的猜想

**哥德巴赫猜想（1+1）**: 每个大于2的偶数n是两个素数的和。
"3+4","3+3","2+3" – Y. Wang, 1956
"1+5" – C. Pan, 1962
"1+4" – Y. Wang, 1962
"1+2" – J. Chen, 1973

**孪生素数猜想**: 有无穷多个孪生素数。

## 线性同余

形式为ax≡b (mod m)的同余，其中m是正整数，a和b是整数，x是变量，称为线性同余。线性同余ax≡b (mod m)的解是所有满足该同余的整数x。

线性同余系统自古就已被研究。大约1500年前，中国数学家孙子问："物不知数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？"

## 模逆

整数ā使得āa≡1 (mod m)被称为a模m的逆。求解线性同余的一种方法使用逆ā（如果存在）。从ax≡b (mod m)，得出āax≡āb (mod m)，然后x≡āb (mod m)。

a模m的逆何时存在？

## 模m的逆

**定理** 如果a和m是互质的整数且m>1，那么a模m的逆存在。此外，逆模m是唯一的。

**证明**. 由于gcd(a,m)=1，存在整数s和t使得sa+tm=1。因此sa+tm≡1 (mod m)。由于tm≡0 (mod m)，得出sa≡1 (mod m)。这意味着s是a模m的逆。

如何证明逆的唯一性？

## 如何找到逆？

使用扩展欧几里得算法

**示例**. 找到101模4620的逆。

## 使用逆求解同余

通过将同余ax≡b (mod m)两边乘以ā来求解。

**示例**. 同余3x≡4 (mod 7)的解是什么？
**解**: 我们发现-2是3模7的逆。将同余两边乘以-2，我们有x≡-8≡6 (mod 7)。

## 中国剩余定理

大约1500年前，中国数学家孙子问："物不知数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？"
x≡2 (mod 3)
x≡3 (mod 5)
x≡2 (mod 7)

## 中国剩余定理

**定理**（中国剩余定理）设m₁,m₂,...,mₙ是两两互质的正整数，大于1，a₁,a₂,...,aₙ是任意整数。那么系统
x≡a₁ (mod m₁)
x≡a₂ (mod m₂)
···
x≡aₙ (mod mₙ)
有一个模m=m₁m₂···mₙ的唯一解。

## 中国剩余定理

**证明** 设Mₖ=m/mₖ对于k=1,2,...,n且m=m₁m₂···mₙ。由于gcd(mₖ,Mₖ)=1，存在整数yₖ，Mₖ模mₖ的逆，使得Mₖyₖ≡1 (mod mₙ)。设x=a₁M₁y₁+a₂M₂y₂+···aₙMₙyₙ。可以检查x是n个同余的解。

如何证明模m的解的唯一性？

## 中国剩余定理

**示例**
x≡2 (mod 3)
x≡3 (mod 5)
x≡2 (mod 7)
设m=3·5·7=105, M₁=m/3=35, M₂=m/5=21, M₃=m/7=15。
35·2≡1 (mod 3)
21≡1 (mod 5)
15≡1 (mod 7)
y₁=2
y₂=1
y₃=1
x=2·35·2+3·21·1+2·15·1≡233≡23 (mod 105)

## 计算机科学中的模算术

模算术和同余在计算机科学中使用：
- 伪随机数生成器
- 哈希函数
- 密码学

## 下节课内容
- 密码学

## 相关知识点总结
- [[数论与同余]] - 数论与同余知识分块总结
- [[离散数学总览]] - 离散数学整体概述
