# Hulec06 - 算法复杂性

## 集合基数回顾

**回顾**: 有限集的基数由集合中元素的数量定义。

如果A和B的元素之间存在一一对应关系，则集合A和B具有相同的基数。

要么是有限的，要么与正整数集Z⁺具有相同基数的集合称为可数集。不是可数的集合称为不可数集。

**为什么这些被称为可数？**
- 集合的元素可以被枚举和列出。

## 可数集示例

**示例3** (定理): （正）有理数集是可数的。

**解决方案**: 构造列表：首先列出p/q，其中p+q=2，然后列出p+q=3的p/q，依此类推。
1, 1/2, 2, 3, 1/3, 1/4, 2/3, ...

## 不可数集

**定理**: 实数集R是不可数的。

**反证法证明**: 假设R是可数的。那么R的每个子集都是可数的（为什么？），特别是从0到1的区间是可数的。这意味着该集合的元素可以列为r₁, r₂, r₃, ...，其中
- r₁ = 0.d₁₁d₁₂d₁₃d₁₄···
- r₂ = 0.d₂₁d₂₂d₂₃d₂₄···
- r₃ = 0.d₃₁d₃₂d₃₃d₃₄···
所有dᵢⱼ∈{0,1,2,...,9}。

**证明继续**: 我们想证明并非所有在0和1之间的实数都在这个列表中。形成一个新数r=0.d₁d₂d₃d₄···，其中如果dᵢᵢ≠2则dᵢ=2，如果dᵢᵢ=2则dᵢ=3。

**证明完成**: 我们声称r与列表中的每个数都不同。每个展开是唯一的，如果我们排除无限9的字符串。r和rᵢ在第i个小数位上不同，对于所有i。这称为康托对角线论证。

## 幂集的不可数性

**定理**: 集合P(N)是不可数的。

**反证法证明**: 假设P(N)是可数的。这意味着该集合的元素可以列为S₀, S₁, S₂, ...，其中Sᵢ⊆N，并且每个Sᵢ可以唯一地由位串bᵢ₀bᵢ₁bᵢ₂...表示，其中如果j∈Sᵢ则bᵢⱼ=1，如果j∉Sᵢ则bᵢⱼ=0
- S₀ = b₀₀b₀₁b₀₂b₀₃···
- S₁ = b₁₀b₁₁b₁₂b₁₃···
- S₂ = b₂₀b₂₁b₂₂b₂₃···
...所有bᵢⱼ∈{0,1}。

**证明继续**: 形成一个新集合R=b₀b₁b₂b₃···，其中如果bᵢᵢ=1则bᵢ=0，如果bᵢᵢ=0则bᵢ=1。我们声称R与列表中的每个集合都不同。每个位串是唯一的，并且R和Rᵢ在第i位上不同，对于所有i。

## 施罗德-伯恩斯坦定理

**定理**: 如果A和B是满足|A|≤|B|和|B|≤|A|的集合，那么|A|=|B|。

换句话说，如果存在从A到B的一对一函数f和从B到A的一对一函数g，那么A和B之间存在一一对应关系。

**示例**: 证明|(0,1)| = |(0,1]|。
f(x)=x; g(x)=x/2

## 算法

算法是执行计算或解决问题的精确指令的有限序列。

## 大O符号

哪个函数"更大"？110n² 还是 100n + 10000

这取决于n的值。在计算机科学中，我们通常对问题输入规模变大时发生的情况感兴趣。

注意当n"足够大"时，110n²变得比100n+10000大得多，并且保持更大。

### 大O符号定义

设f和g是从整数集或实数集到实数集的函数。我们说f(n)=O(g(n))（读作：f(n)是g(n)的大O），如果存在正常数C和x₀，使得当n>x₀时，|f(n)| ≤ C|g(n)|。

### 大O符号示例

110n² 和 100n+10000
设k=1091
可以验证对于所有n>k，100n+10000 ≤ 110n²
因此，100n+10000 = O(110n²)
注意相反不成立！（为什么？）（反证法证明）

**示例**:
4n², 8n²+2n-3, n²/5+√n, 10logn, n(n-3) 都是 O(n²)

### 多项式的大O估计

设f(x)=aₙxⁿ + aₙ₋₁xⁿ⁻¹ + ··· + a₁x + a₀，其中a₀,a₁,...,aₙ是实数。那么f(x)=O(xⁿ)。

**证明**: 假设x>1，我们有
|f(x)| = |aₙxⁿ + aₙ₋₁xⁿ⁻¹ + ··· + a₁x + a₀|
≤ |aₙ|xⁿ + |aₙ₋₁|xⁿ⁻¹ + ··· + |a₁|x + |a₀|
= xⁿ(|aₙ| + |aₙ₋₁|/x + ··· + |a₁|/xⁿ⁻¹ + |a₀|/xⁿ)
≤ xⁿ(|aₙ| + |aₙ₋₁| + ··· + |a₁| + |a₀|)。

多项式的主导项aₙxⁿ主导其增长。

### 一些函数的大O估计
1+2+···+n = O(n²)
n! = O(nⁿ)
logn! = O(nlogn)
nᵃ = O(2ⁿ) 对于整数a
logₐn = O(n) 对于整数a≥2
nᵃ = O(nᵇ) 对于整数a≤b

## 函数组合

如果f₁(x)是O(g₁(x))且f₂(x)是O(g₂(x))，那么(f₁+f₂)(x) = O(max(|g₁(x)|, |g₂(x)|))

**证明**: 根据定义，存在常数C₁, C₂, k₁, k₂使得当x>k₁时|f₁(x)| ≤ C₁|g₁(x)|，当x>k₂时|f₂(x)| ≤ C₂|g₂(x)|。
那么|(f₁+f₂)(x)| = |f₁(x)+f₂(x)| ≤ |f₁(x)| + |f₂(x)| ≤ C₁|g₁(x)| + C₂|g₂(x)| ≤ C₁|g(x)| + C₂|g(x)| = (C₁+C₂)|g(x)| = C|g(x)|，其中g(x)=max(|g₁(x)|, |g₂(x)|)且C=C₁+C₂。

如果f₁(x)是O(g₁(x))且f₂(x)是O(g₂(x))，那么(f₁f₂)(x) = O(g₁(x)g₂(x))

**证明**: 当x>max(k₁,k₂)时，|(f₁f₂)(x)| = |f₁(x)||f₂(x)| ≤ C₁|g₁(x)|C₂|g₂(x)| ≤ C₁C₂|(g₁g₂)(x)| ≤ C|(g₁g₂)(x)|，其中C=C₁C₂。

## 按增长顺序排列函数

f₁(n) = (1.5)ⁿ
f₂(n) = 8n³ + 17n² + 111
f₃(n) = (logn)²
f₄(n) = 2ⁿ
f₅(n) = log(logn)
f₆(n) = n²(logn)³
f₇(n) = 2ⁿ(n²+1)
f₈(n) = n³ + n(logn)²
f₉(n) = 100000
f₁₀(n) = n!

## 大Ω符号

设f和g是从整数集或实数集到实数集的函数。我们说f(n)=Ω(g(n))（读作：f(n)是g(n)的大Ω），如果存在正常数C和x₀，使得当n>x₀时，|f(n)| ≥ C|g(n)|。

大O给出函数增长的上界，而大Ω给出下界。大Ω告诉我们一个函数至少以另一个函数的速度增长。

**注意**: f(x)是Ω(g(x))当且仅当g(x)是O(f(x))。

## 大Θ符号（大O和大Ω）

如果f(n)=O(g(n))且g(n)=O(f(n))，则两个函数f(n),g(n)具有相同的增长阶。在这种情况下，我们说f(n)=Θ(g(n))，这与g(n)=Θ(f(n))相同。

### 示例（f(n)=Θ(g(n))）
- 3n²+4n = Θ(n)? 否
- 3n²+4n = Θ(n²)? 是
- 3n²+4n = Θ(n³)? 否，但是O(n³)
- n/5+10nlogn = Θ(n²)? 否，但是O(n²)
- n²/5+10nlogn = Θ(nlogn)? 否
- n²/5+10nlogn = Θ(n²)? 是

## 算法

算法是执行计算或解决问题的精确指令的有限序列。

计算问题是期望输入-输出关系的规范。

**示例**（计算问题和算法）
以下过程是计算n个给定数字a₁,a₂,...,aₙ之和的算法。
步骤1: 设S=0
步骤2: 对于i=1到n，将S替换为S+aᵢ
步骤3: 输出S

## 实例

问题的实例是计算问题解决方案所需的所有输入。

**示例**（问题实例）
<8,3,6,7,1,2,9>

正确的算法对每个输入实例都会停止并产生正确的输出。然后我们可以说该算法解决了问题。

## 时间和空间复杂度

算法所需的机器操作数（加法、乘法、比较、替换等）是算法的时间复杂度，所需的内存量是算法的空间复杂度。

**示例**（算法）
步骤1: 设S=0
步骤2: 对于i=1到n，将S替换为S+aᵢ
步骤3: 输出S

步骤1和步骤3各需要1次操作。步骤2需要2n次操作。因此，该算法总共需要2n+2次操作。时间复杂度是O(n)。

## 霍纳算法及其复杂度

**示例** 考虑计算f(x)=1+2x+3x²+4x³。
直接计算需要3次加法和6次乘法。我们能做得更好吗？

另一种方法是f(x)=1+x(2+x(3+4x))，需要3次加法和3次乘法。

步骤1: 设S=aₙ
步骤2: 对于i=1到n，将S替换为aₙ₋ᵢ + Sx
步骤3: 输出S

### 霍纳算法及其复杂度
步骤1: 设S=aₙ
步骤2: 对于i=1到n，将S替换为aₙ₋ᵢ + Sx
步骤3: 输出S

步骤3输出的S的最终值是期望值a₀+a₁x+···+aₙxⁿ。

该算法需要的操作数是1+3n+1=3n+2。因此该算法的时间复杂度是O(n)。

## 时间复杂度

确定以下算法的时间复杂度：
```
for i := 1 to n
    for j := 1 to n
        a := 2*n + i*j;
    end for
end for
```

在第二个循环中，计算a需要4次操作（两次乘法、一次加法、一次替换）。对于每个i，完成第二个循环需要4n次操作。因此完成两个循环需要n×4n=4n²次操作。该算法的时间复杂度是O(n²)。

确定以下算法的时间复杂度：
```
S := 0
for i := 1 to n
    for j := 1 to i
        S := S + i*j;
    end for
end for
```

计算S需要3次操作。对于每个i，完成第二个循环需要3i次操作。因此总共需要1+∑ᵢ₌₁ⁿ 3i = 1+3n(n+1)/2次操作。因此该算法的复杂度是O(n²)。

## 更多关于时间复杂度

**示例**:（插入排序）
输入: A[1...n]是数字数组
```
for j := 2 to n
    key = A[j];
    i = j-1;
    while i ≥ 1 and A[i] > key do
        A[i+1] = A[i];
        i--;
    end while
    A[i+1] = key;
end for
```

## 分析的三种情况

### I. 最好情况
输入的约束（除了大小）导致给定大小的最快可能运行时间。

**示例**:（插入排序）
A[1] ≤ A[2] ≤ A[3] ≤ ··· ≤ A[n]
需要的比较次数是1+1+1+···+1（n-1次）= n-1 = Θ(n)

### II. 最坏情况
输入的约束（除了大小）导致给定大小的最慢可能运行时间。

**示例**:（插入排序）
A[1] ≥ A[2] ≥ A[3] ≥ ··· ≥ A[n]
需要的比较次数是1+2+3+···+(n-1) = n(n-1)/2 = Θ(n²)

### III. 平均情况
给定大小的所有可能输入类型的平均运行时间（通常涉及不同类型输入的概率）

**示例**:（插入排序）
Θ(n²) 假设n!个实例中的每一个都等可能

## 关于算法设计的一些思考

算法设计主要是设计具有小大O运行时间的算法。能够进行良好的算法设计可以让你识别问题的困难部分并有效处理它们。

通常，程序员试图使用暴力技术解决问题，最终得到缓慢复杂的代码！投入几个小时的抽象思考进行算法设计可以显著加快解决方案并简化它！

## 处理困难问题

如果你找不到给定问题的有效算法怎么办？

**责备自己**: 我找不到多项式时间算法。我想我太笨了。

**证明困难性**: 我找不到多项式时间算法，因为不存在这样的算法。证明不存在有效算法。

## 处理困难问题

证明问题有有效算法相对容易："所有"需要的是演示一个算法。

证明特定问题不存在有效算法是困难的：我们如何证明某物不存在？

我们现在将学习NP完全问题，这为我们提供了一种处理这个问题的方法。

## 引言

一个非常大的类，包含数千个实际问题，不知道这些问题是否有"有效"解决方案。

已知如果任何一个NP完全问题有有效解决方案，那么所有NP完全问题都有有效解决方案。

研究人员花费了无数人年试图找到这些问题的有效解决方案但失败了。因此，NP完全问题很可能是困难的。

**你该做什么**: 证明你的问题是NP完全的。

## 引言

我找不到多项式时间算法，但所有其他聪明人也找不到！

**你实际做什么**:

## 下节课内容
- P vs NP
- 数论

## 相关知识点总结
- [[算法与复杂度]] - 算法与复杂度知识分块总结
- [[离散数学总览]] - 离散数学整体概述
