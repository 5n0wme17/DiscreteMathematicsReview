# Hulec07 - 计算复杂性与数论基础

## 算法设计思考

算法设计主要是设计具有小大O运行时间的算法。能够进行良好的算法设计可以让你识别问题的困难部分并有效处理它们。

通常，程序员试图使用暴力技术解决问题，最终得到缓慢复杂的代码！投入几个小时的抽象思考进行算法设计可以显著加快解决方案并简化它！

## 处理困难问题

如果你找不到给定问题的有效算法怎么办？

**责备自己**: 我找不到多项式时间算法。我想我太笨了。

**证明困难性**: 我找不到多项式时间算法，因为不存在这样的算法。证明不存在有效算法。

## 处理困难问题

证明问题有有效算法相对容易："所有"需要的是演示一个算法。

证明特定问题不存在有效算法是困难的：我们如何证明某物不存在？

我们现在将学习NP完全问题，这为我们提供了一种处理这个问题的方法。

## 引言

一个非常大的类，包含数千个实际问题，不知道这些问题是否有"有效"解决方案。

已知如果任何一个NP完全问题有有效解决方案，那么所有NP完全问题都有有效解决方案。

研究人员花费了无数人年试图找到这些问题的有效解决方案但失败了。因此，NP完全问题很可能是困难的。

**你该做什么**: 证明你的问题是NP完全的。

## 引言

我找不到多项式时间算法，但所有其他聪明人也找不到！

**你实际做什么**:

## 问题输入的编码

问题的复杂性是相对于输入大小来衡量的。为了正式讨论问题的难度，我们需要比以前更正式地讨论问题的输入大小。

## 问题的输入大小

问题的输入大小可以通过多种方式定义。

**定义**: 问题的输入大小是编码问题输入所需的最小位数({0,1})。

在大多数情况下，由最优编码方法确定的精确输入大小很难计算。然而，我们不需要精确确定。对于大多数问题，选择一些自然的（通常是简单的）编码并使用这种编码的大小就足够了。

## 输入大小示例：合数

**示例**: 给定正整数n，是否存在整数j,k>1使得n=jk？（即，n是合数吗？）

**问题**: 这个问题的输入大小是多少？

任何整数n>0都可以在二进制数系统中表示为长度为⌈log₂(n+1)⌉的字符串a₀a₁···aₖ。因此，输入大小的自然度量是⌈log₂(n+1)⌉（或只是log₂n）

## 输入大小示例：排序

**示例**: 排序n个整数a₁,...,aₙ

**问题**: 这个问题的输入大小是多少？

使用固定长度编码，我们将aᵢ写为长度为m=⌈log₂(max(|aᵢ|+1))⌉的二进制字符串。这种编码给出的输入大小为nm。

## 输入大小方面的复杂性

**示例**:（合数）
确定n是否为合数的朴素算法将n与前n-1个数进行比较，看是否有任何一个能整除n
这需要Θ(n)次比较，所以看起来是线性的且非常有效。但是，注意这个问题的输入大小是size(n)=log₂n，所以执行的比较次数实际上是Θ(n)=Θ(2^size(n))，这是指数级的。

## 问题的输入大小

**定义**: 如果对于所有大的n，c₁g(n^a₁)^b₁ ≤ f(n) ≤ c₂g(n^a₂)^b₂，其中a₁,b₁,c₁,a₂,b₂,c₂是一些正常数，则两个正函数f(n)和g(n)是相同类型的。

**示例**: 所有多项式都是相同类型的，但多项式和指数函数是不同类型的。

## 输入大小示例：整数乘法

**示例**:（整数乘法问题）计算a×b。

**问题**: 这个问题的输入大小是多少？

最小输入大小是s=⌈log₂(a+1)⌉+⌈log₂(b+1)⌉。自然的选择是使用t=log₂max(a,b)，因为s/2 ≤ t ≤ s。

## 决策问题

**定义**: 决策问题是有两个可能答案的问题：是和否。如果L是问题，x是输入，我们经常写x∈L表示是答案，x∉L表示否答案。

## 优化问题

**定义**: 优化问题需要一个最优配置作为答案。优化问题通常有相应的决策问题。

**示例**: 背包问题 vs 决策背包问题

## 背包问题 vs 决策背包问题

我们有一个容量为W（正整数）的背包和n个对象，重量为w₁,...,wₙ，价值为v₁,...,vₙ，其中vᵢ和wᵢ是正整数。

**优化问题**:（背包问题）找到任何适合背包的子集T的最大值∑ᵢ∈T vᵢ，即∑ᵢ∈T wᵢ ≤ W。

**决策问题**:（决策背包问题）给定k，是否存在对象的子集适合背包且总价值至少为k？

## 优化和决策问题

给定解决优化问题的子程序，解决相应的决策问题通常是微不足道的。首先解决优化问题，然后检查决策问题。如果是，回答是，否则否。

因此，如果我们证明给定的决策问题难以有效解决，那么显然优化问题必须（至少同样）困难。

## 复杂性类

复杂性理论处理：
- 将某些"决策问题"分类为几个类：
  - "简单"问题类
  - "困难"问题类
  - "最困难"问题类
- 三个类之间的关系
- 三个类中问题的性质

**问题**: 如何对决策问题进行分类？
**答案**: 使用多项式时间算法。

## 多项式时间算法

**定义**: 如果算法的运行时间是O(nᵏ)，其中k是与n无关的常数，n是算法解决的问题的输入大小，则该算法是多项式时间的。

我们使用n还是nᵃ（对于固定的a>0）作为输入大小，不会影响算法是否是多项式时间的结论。

**示例**: 标准乘法算法的时间为O(m₁m₂)，其中m₁,m₂分别表示两个整数中的位数。

## 多项式时间 vs 非多项式时间

非多项式时间算法是不实用的。对于n=100，2ⁿ需要数十亿年！！！

实际上，O(n²⁰)算法并不真正实用。

## 多项式时间可解问题

**定义**: 如果存在在多项式时间内解决问题的算法，则问题在多项式时间内可解（或更简单地说，问题在多项式时间内）（也称为可处理的）。

**定义**（P类）: P类由所有在多项式时间内可解的决策问题组成。也就是说，存在一个算法，对于任何给定的输入，将在多项式时间内决定它是是输入还是否输入。

## P类

**问题**: 如何证明决策问题在P中？
**答案**: 找到多项式时间算法。

**问题**: 如何证明决策问题不在P中？
**答案**: 你需要证明这个问题没有多项式时间算法。（困难得多）

## 数论的应用

G.H. Hardy (1877-1947) 在他1940年的自传《一个数学家的辩白》中写道："应用数学的现代伟大成就是在相对论和量子力学中，而这些学科目前几乎和数论一样'无用'。"

如果他能看到现在的世界，Hardy会在坟墓里打转。

## 数论

数论是探索整数及其性质的数学分支，是密码学、编码理论、计算机安全、电子商务等的基础。

曾经，美国（可能也是世界）最大的数学家雇主是美国国家安全局（NSA）。NSA是美国最大的间谍机构（比中央情报局CIA还大），负责代码设计和破解。

## 整除性

如果a和b是整数且a≠0，我们说a整除b，如果存在整数c使得b=ac，或者等价地b/a是整数。在这种情况下，我们说a是b的因子或除数，b是a的倍数。（我们使用符号a|b，a∤b）

**示例**
- 4|24
- 3∤7

## 整除性

所有能被d>0整除的整数可以枚举为：..., -kd, ..., -2d, -d, 0, d, 2d, ..., kd, ...

**问题**: 设n和d是两个正整数。不超过n的正整数中有多少个能被d整除？
**答案**: 计算满足0<kd≤n的整数个数。因此，有⌊n/d⌋个这样的正整数。

## 整除性性质

设a,b,c是整数。那么以下成立：
(i) 如果a|b且a|c，那么a|(b+c)
(ii) 如果a|b，那么对于所有整数c，a|bc
(iii) 如果a|b且b|c，那么a|c

**证明**.

## 整除性推论

如果a,b,c是整数，其中a≠0，使得a|b且a|c，那么当m和n是整数时，a|(mb+nc)

**证明**. 根据性质的(ii)部分和(i)部分。

## 除法算法

如果a是整数且d是正整数，那么存在唯一的整数q和r，满足0≤r<d，使得a=dq+r。在这种情况下，d称为除数，a称为被除数，q称为商，r称为余数。在这种情况下，我们使用符号q=a div d和r=a mod d。

## 同余关系

如果a和b是整数且m是正整数，那么a模m同余于b，如果m整除a-b，记作a≡b (mod m)。这称为同余，m是其模数。

**示例**
- 15≡3 (mod 6)
- -1≡11 (mod 6)

## 更多关于同余

设m是正整数。整数a和b模m同余当且仅当存在整数k使得a=b+km。

**证明**. "仅当"部分 "当"部分

## (mod m) 和 mod m 符号

a≡b (mod m) 和 a mod m = b 是不同的。
- a≡b (mod m) 是整数集上的关系
- 在 a mod m = b 中，符号 mod 表示函数

设a和b是整数，m是正整数。那么a≡b mod m当且仅当a mod m = b mod m

**证明**.

## 和与积的同余

**证明**. 设m是正整数。如果a≡b (mod m)且c≡d (mod m)，那么a+c≡b+d (mod m)且ac≡bd (mod m)

## 同余的代数操作

如果a≡b mod m，那么
- c·a≡c·b (mod m)?
- c+a≡c+b (mod m)?
- a/c≡b/c (mod m)?

14≡8 (mod 6) 但 7≢4 (mod 6)

## 计算mod函数

**推论** 设m是正整数，a和b是整数。那么
(a+b) mod m = ((a mod m) + (b mod m)) mod m
ab mod m = ((a mod m)(b mod m)) mod m

**证明**.

## 模m算术

设Zₘ是非负整数小于m的集合：{0,1,...,m-1}。
+ₘ: a +ₘ b = (a+b) mod m
·ₘ: a ·ₘ b = ab mod m

**示例**
- 7 +₁₁ 9 = ?
- 7 ·₁₁ 9 = ?

## 模m算术

**封闭性**: 如果a,b∈Zₘ，那么a+ₘb, a·ₘb∈Zₘ
**结合律**: 如果a,b,c∈Zₘ，那么(a+ₘb)+ₘc = a+ₘ(b+ₘc) 且 (a·ₘb)·ₘc = a·ₘ(b·ₘc)
**分配律**: 如果a,b,c∈Zₘ，那么a·ₘ(b+ₘc) = (a·ₘb)+ₘ(a·ₘc) 且 (a+ₘb)·ₘc = (a·ₘc)+ₘ(b·ₘc)
**单位元**: a+ₘ0 = a 且 a·ₘ1 = a
**加法逆元**: 如果a≠0且a∈Zₘ，那么m-a是a模m的加法逆元
**交换律**: 如果a,b∈Zₘ，那么a+ₘb = b+ₘa

## 整数的表示

我们可以使用十进制（基10）或二进制或八进制或十六进制或其他符号来表示整数。

设b>1是整数。那么如果n是正整数，它可以唯一地表示为形式n = aₖbᵏ + aₖ₋₁bᵏ⁻¹ + ··· + a₁b + a₀，其中k是非负的，aᵢ's是小于b的非负整数。n的表示称为n的基b展开，记作(aₖaₖ₋₁...a₁a₀)₆。

## 基b展开

获得十进制展开很容易。

**示例**
- (101011111)₂ = 2⁸ + 2⁶ + 2⁴ + 2³ + 2² + 2¹ + 2⁰ = 351
- (7016)₈ = 7·8³ + 1·8 + 6 = 3598

二进制、八进制、十六进制展开之间的转换很容易。

**示例**
- (101011111)₂ = (101 011 111) = (537)₈
- (7016)₈ = (111 000 001 110)₂ = (1110 0000 1110)₂ = (E0E)₁₆

## 基b展开

n = aₖbᵏ + aₖ₋₁bᵏ⁻¹ + aₖ₋₂bᵏ⁻² + ··· + a₂b² + a₁b + a₀
= b(aₖbᵏ⁻¹ + aₖ₋₁bᵏ⁻² + aₖ₋₂bᵏ⁻³ + ··· + a₂b + a₁) + a₀
= b(b(aₖbᵏ⁻² + aₖ₋₁bᵏ⁻³ + aₖ₋₂bᵏ⁻⁴ + ··· + a₂) + a₁) + a₀
= ···

要构造整数n的基b展开：
- 将n除以b得到n = bq₀ + a₀，其中0 ≤ a₀ < b
- 余数a₀是n的基b展开中最右边的数字。然后将q₀除以b得到q₀ = bq₁ + a₁，其中0 ≤ a₁ < b
- a₁是从右边数的第二个数字。继续依次将商除以b，直到商为0

## 算法：构造基b展开

## 示例
(12345)₁₀ = (30071)₈
12345 = 8·1543 + 1
1543 = 8·192 + 7
192 = 8·24 + 0
24 = 8·3 + 0
3 = 8·0 + 3

## 整数的二进制加法
a = (aₙ₋₁aₙ₋₂...a₁a₀)₂, b = (bₙ₋₁bₙ₋₂...b₁b₀)₂
O(n)位加法

## 算法：整数的二进制乘法
a = (aₙ₋₁aₙ₋₂...a₁a₀)₂, b = (bₙ₋₁bₙ₋₂...b₁b₀)₂
ab = a(b₀2⁰ + b₁2¹ + ··· + bₙ₋₁2ⁿ⁻¹)
= a(b₀2⁰) + a(b₁2¹) + ··· + a(bₙ₋₁2ⁿ⁻¹)
O(n²)移位和O(n²)位加法

## 算法：计算div和mod
O(q log a)位操作。但存在更有效的算法，复杂度为O(n²)，其中n=max(log a, log d)

## 算法：二进制模幂运算
依次找到b mod m, b² mod m, b⁴ mod m, ..., b²ᵏ⁻¹ mod m，并将aⱼ=1的项b²ʲ相乘。
bⁿ = b^(aₖ₋₁·2ᵏ⁻¹ + ··· + a₁·2 + a₀) = b^(aₖ₋₁·2ᵏ⁻¹)···b^(a₁·2)·b^(a₀)
O((log m)² log n)位操作

## 下节课内容
- 数论
- 密码学

## 相关知识点总结
- [[算法与复杂度]] - 算法与复杂度知识分块总结
- [[数论与同余]] - 数论与同余知识分块总结
- [[离散数学总览]] - 离散数学整体概述
