# 算法与复杂度

## 概述
算法与复杂度研究算法的设计、分析和效率评估，是计算机科学的核心内容。复杂度理论帮助我们理解问题的计算难度和算法的效率界限。

## 算法复杂度分析

### 算法的定义
算法是执行计算或解决问题的精确指令的有限序列。

### 计算问题
计算问题是期望输入-输出关系的规范。

### 问题实例
问题的实例是计算问题解决方案所需的所有输入。

### 正确算法
正确的算法对每个输入实例都会停止并产生正确的输出。

## 时间复杂度与空间复杂度

### 时间复杂度
算法所需的机器操作数（加法、乘法、比较、替换等）是算法的时间复杂度。

### 空间复杂度
算法所需的内存量是算法的空间复杂度。

### 示例：求和算法
```
步骤1: 设S=0
步骤2: 对于i=1到n，将S替换为S+aᵢ
步骤3: 输出S
```
- 步骤1和步骤3各需要1次操作
- 步骤2需要2n次操作
- 总操作数：2n+2，时间复杂度是O(n)

## 大O符号

### 大O定义
设f和g是从整数集或实数集到实数集的函数。我们说f(x)=O(g(x))，如果存在正常数C和k，使得当x>k时，|f(x)| ≤ C|g(x)|。

### 大O的意义
大O给出函数增长的上界，描述算法的最坏情况性能。

### 常见复杂度类
- O(1): 常数时间
- O(log n): 对数时间
- O(n): 线性时间
- O(n log n): 线性对数时间
- O(n²): 平方时间
- O(2ⁿ): 指数时间
- O(n!): 阶乘时间

### 大O性质
- 如果f₁(x)是O(g₁(x))且f₂(x)是O(g₂(x))，那么(f₁+f₂)(x) = O(max(|g₁(x)|, |g₂(x)|))
- 如果f₁(x)是O(g₁(x))且f₂(x)是O(g₂(x))，那么(f₁f₂)(x) = O(g₁(x)g₂(x))

## 大Ω符号

### 大Ω定义
设f和g是从整数集或实数集到实数集的函数。我们说f(n)=Ω(g(n))，如果存在正常数C和x₀，使得当n>x₀时，|f(n)| ≥ C|g(n)|。

### 大Ω的意义
大Ω给出函数增长的下界，描述算法的最好情况性能。

### 大Ω与大O的关系
f(x)是Ω(g(x))当且仅当g(x)是O(f(x))。

## 大Θ符号

### 大Θ定义
如果f(n)=O(g(n))且g(n)=O(f(n))，则两个函数f(n),g(n)具有相同的增长阶。我们说f(n)=Θ(g(n))。

### 大Θ的意义
大Θ给出函数增长的紧确界，描述算法的平均情况性能。

### 示例
- 3n²+4n = Θ(n)? 否
- 3n²+4n = Θ(n²)? 是
- 3n²+4n = Θ(n³)? 否，但是O(n³)

## 算法设计实例

### 霍纳算法
用于计算多项式f(x)=a₀+a₁x+a₂x²+...+aₙxⁿ的高效算法。

**算法步骤**:
1. 设S=aₙ
2. 对于i=1到n，将S替换为aₙ₋ᵢ + Sx
3. 输出S

**复杂度分析**:
- 操作数：1+3n+1=3n+2
- 时间复杂度：O(n)

### 插入排序算法
```
for j := 2 to n
    key = A[j];
    i = j-1;
    while i ≥ 1 and A[i] > key do
        A[i+1] = A[i];
        i--;
    end while
    A[i+1] = key;
end for
```

## 复杂度分析的三种情况

### 最好情况
输入的约束（除了大小）导致给定大小的最快可能运行时间。

**插入排序最好情况**:
A[1] ≤ A[2] ≤ A[3] ≤ ··· ≤ A[n]
比较次数：n-1 = Θ(n)

### 最坏情况
输入的约束（除了大小）导致给定大小的最慢可能运行时间。

**插入排序最坏情况**:
A[1] ≥ A[2] ≥ A[3] ≥ ··· ≥ A[n]
比较次数：n(n-1)/2 = Θ(n²)

### 平均情况
给定大小的所有可能输入类型的平均运行时间。

**插入排序平均情况**:
Θ(n²) 假设n!个实例中的每一个都等可能

## 算法设计原则

### 算法设计目标
设计具有小大O运行时间的算法。

### 设计策略
- 识别问题的困难部分并有效处理
- 避免暴力技术导致的缓慢复杂代码
- 投入抽象思考进行算法设计可以显著加快解决方案

## NP完全问题

### 困难问题处理
如果找不到给定问题的有效算法：

1. **自我反思**: 可能没有找到多项式时间算法
2. **证明困难性**: 证明不存在有效算法

### NP完全问题类
- 包含数千个实际问题的大类
- 不知道这些问题是否有"有效"解决方案
- 如果任何一个NP完全问题有有效解决方案，那么所有NP完全问题都有有效解决方案

### NP完全问题的意义
研究人员花费了无数人年试图找到这些问题的有效解决方案但失败了。因此，NP完全问题很可能是困难的。

### 实际应对策略
证明问题是NP完全的，然后：
- 使用近似算法
- 使用启发式方法
- 处理小规模实例

## 复杂度理论的应用

### 算法选择
根据问题规模选择合适的算法：
- 小规模问题：简单算法
- 大规模问题：高效算法

### 性能预测
通过复杂度分析预测算法在实际应用中的性能。

### 问题分类
将问题按计算难度分类，指导算法设计策略。

## 相关链接
- [[计数原理与组合数学]]
- [[数论与同余]]
- [[图论与关系]]
- [[离散数学总览]]

---
*本笔记基于离散数学课程内容整理，主要参考教材《Discrete Mathematics and Its Applications》*
