# Hulec22 - 树与生成树

## 欧拉公式

**定理（欧拉公式）** 设 G 是具有 e 条边和 v 个顶点的连通平面简单图。设 r 是 G 的平面表示中的区域数。那么 r = e - v + 2。

**推论 1** 如果 G 是具有 e 条边和 v 个顶点的连通平面简单图，其中 v ≥ 3，那么 e ≤ 3v - 6。

**推论 2** 如果 G 是连通平面简单图，那么 G 有一个度不超过 5 的顶点。

**推论 3** 在具有 e 条边和 v 个顶点的连通平面简单图中，如果 v ≥ 3 且没有长度为三的回路，那么 e ≤ 2v - 4。

## 图着色

简单图的着色是将颜色分配给图的每个顶点，使得没有两个相邻顶点被分配相同颜色。

图的色数是该图着色所需的最少颜色数，记作 χ(G)。

## 示例

Kₙ, Kₘ,ₙ, Cₙ 的色数是多少？

## 图着色

**定理（六色定理）** 平面图的色数不大于六。

**证明** (通过对顶点数的归纳)
不失一般性，假设图是连通的。

基本情况：对于单个顶点，选择任意颜色。

归纳假设：假设每个具有 k-1 个或更少顶点的平面图都可以 6-着色。

归纳步骤：考虑具有 k+1 个顶点的平面图。
回忆推论 2（图有一个度不超过 5 的顶点）。移除这个顶点，根据归纳假设，我们可以用 6 种颜色为剩余图着色。将顶点放回。由于最多有 5 种相邻颜色，所以我们至少有一种颜色剩余。

## 图着色

**定理（五色定理）** 平面图的色数不大于五。

**证明** (通过对顶点数的归纳)
不失一般性，假设图是连通的。

基本情况：对于单个顶点，选择任意颜色。

归纳假设：假设每个具有 k-1 个或更少顶点的平面图都可以 5-着色。

归纳步骤：考虑具有 k+1 个顶点的平面图。
回忆推论 2（图有一个度不超过 5 的顶点）。移除这个顶点，根据归纳假设，我们可以用 5 种颜色为剩余图着色。将顶点放回。

如果顶点的度小于 5，或者如果它的度为 5 且连接到它的顶点只使用 ≤ 4 种颜色，我们可以为它选择一个可用颜色。

如果顶点的度为 5，并且所有 5 种颜色都连接到它，我们将与"特殊"顶点（度为 5）相邻的顶点标记为 1 到 5（按顺序）。

我们创建一个由所有颜色为 1 或 3 的顶点组成的子图。如果颜色为 1 的相邻顶点和颜色为 3 的相邻顶点在子图中没有通过路径连接。

另一方面，如果颜色为 1 和 3 的顶点通过子图中的路径连接，我们对颜色为 2 和 4 的顶点做同样的事情。注意，这将是一对断开的子图，由连接颜色为 1 和 3 的顶点的路径分隔（为什么？）

## 树

**定义** 树是没有简单回路的连通无向图。

## 树

**定理** 无向图是树当且仅当它的任意两个顶点之间存在唯一的简单路径。

**证明**
树的两个性质：连通，无回路

## 有根树

**定义** 有根树是指定一个顶点为根且每条边都远离根的方向的树。

## 有根树

父节点，子节点，兄弟节点
祖先，后代
叶节点，内部顶点
以 a 为根的子树：由 a 及其后代以及所有与这些后代关联的边组成

## m叉树

**定义** 如果每个内部顶点最多有 m 个子节点，则称有根树为 m 叉树。如果每个内部顶点恰好有 m 个子节点，则称树为满 m 叉树。特别地，m = 2 的 m 叉树称为二叉树。

**定义** 二叉树是有序有根树，其中每个内部顶点的子节点是有序的。在二叉树中，第一个子节点称为左子节点，第二个子节点称为右子节点。

左子树，右子树

## 满 m 叉树中的顶点计数

**定理** 具有 i 个内部顶点的满 m 叉树有 n = mi + 1 个顶点。

**定理** 满 m 叉树具有
(i) n 个顶点
(ii) i 个内部顶点
(iii) ℓ 个叶节点

(i) n 个顶点，i = (n-1)/m，ℓ = [(m-1)n+1)]/m
(ii) i 个内部顶点，n = mi + 1，ℓ = (m-1)i + 1
(iii) ℓ 个叶节点，n = (mℓ-1)/(m-1)，i = (ℓ-1)/(m-1)

使用 n = mi + 1 和 n = i + ℓ

## 层级和高度

有根树中顶点 v 的层级是从根到该顶点的唯一路径的长度。

有根树的高度是顶点层级的最大值。

**定义** 高度为 h 的有根 m 叉树是平衡的，如果所有叶节点都在层级 h 或 h-1。（差异不大于 1）

## 叶节点数

**定理** 高度为 h 的 m 叉树最多有 mʰ 个叶节点。

**证明** (通过归纳法)

**推论** 如果高度为 h 的 m 叉树有 ℓ 个叶节点，那么 h ≥ ⌈logₘℓ⌉。如果 m 叉树是满且平衡的，那么 h = ⌈logₘℓ⌉。

**证明**

## 二叉树

**定义** 二叉树是有序有根树，其中每个内部树有两个子节点，第一个称为左子节点，第二个称为右子节点。以顶点左子节点为根的树称为该顶点的左子树，以右子节点为根的树称为右子树。

## 前序遍历

**定义** 设 T 是以 r 为根的有序有根树。如果 T 只包含 r，那么 r 是 T 的前序遍历。否则，假设 T₁, T₂, ..., Tₙ 是 T 中从左到右的 r 的子树。前序遍历首先访问 r，然后以前序遍历 T₁，然后以前序遍历 T₂，依此类推，直到以前序遍历 Tₙ。

## 前序遍历

**示例**

## 中序遍历

**定义** 设 T 是以 r 为根的有序有根树。如果 T 只包含 r，那么 r 是 T 的中序遍历。否则，假设 T₁, T₂, ..., Tₙ 是 T 中从左到右的 r 的子树。中序遍历首先中序遍历 T₁，然后访问 r，然后继续中序遍历 T₂，依此类推，直到中序遍历 Tₙ。

## 中序遍历

**示例**

## 后序遍历

**定义** 设 T 是以 r 为根的有序有根树。如果 T 只包含 r，那么 r 是 T 的后序遍历。否则，假设 T₁, T₂, ..., Tₙ 是 T 中从左到右的 r 的子树。后序遍历首先后序遍历 T₁，然后后序遍历 T₂，依此类推，在 Tₙ 后序遍历后，访问 r。

## 后序遍历

**示例**

## 前序、中序、后序遍历

## 表达式树

复杂表达式可以使用有序有根树表示

**示例** 考虑表达式 ((x+y)^2) + ((x-4)/3)

## 中缀表示法

表示表达式的树的中序遍历在包含括号时产生原始表达式，除了单目运算。

为什么需要括号？

## 前缀表示法

表达式树的前序遍历导致表达式的前缀形式（波兰表示法）。

在前缀表示法中，运算符位于其操作数之前。不需要括号，因为表示是明确的。

前缀表达式通过从右到左工作来求值。当我们遇到运算符时，我们使用右边的两个操作数执行操作。

## 前缀表示法

**示例** + - * 2 3 5 / " 2 3 4

## 后缀表示法

表达式树的后序遍历导致表达式的后缀形式（逆波兰表示法）。

在后缀表示法中，运算符跟随其操作数。不需要括号，因为表示是明确的。

后缀表达式通过从左到右工作来求值。当我们遇到运算符时，我们使用左边的两个操作数执行操作。

## 后缀表示法

**示例** 7 2 3 * - 4 " 9 3 / +

## 生成树

**定义** 设 G 是简单图。G 的生成树是 G 的子图，它是包含 G 的每个顶点的树。

移除边以避免回路

## 生成树

**定理** 简单图是连通的当且仅当它有生成树。

**证明**
"仅当"部分
生成树可以通过从简单回路中移除边来获得。

"当"部分
容易

## 深度优先搜索

我们可以通过从简单回路中移除边来找到生成树。

但是，这效率低下，因为应该首先识别简单回路。

相反，我们通过连续添加边来构建生成树。

- 首先任意选择图的一个顶点作为根。
- 通过连续添加顶点和边形成路径。尽可能长时间地继续添加到此路径。
- 如果路径经过图的所有顶点，则树是生成树。
- 否则，移动回某个顶点重复此过程（回溯）

## 深度优先搜索

**示例**

## 深度优先搜索算法

时间复杂度：O(e)

## 广度优先搜索

这是第二个算法，我们通过连续添加边来构建生成树。

- 首先任意选择图的一个顶点作为根。
- 通过添加与此顶点关联的所有边以及这些边的另一个端点形成路径
- 对于在前一层级添加的每个顶点，添加与此顶点关联的边，只要它不产生简单回路。
- 继续以这种方式直到所有顶点都被添加。

## 广度优先搜索

**示例**

## 广度优先搜索

时间复杂度：O(e)

## 最小生成树

**定义** 连通加权图中的最小生成树是边权之和尽可能小的生成树。

两个贪心算法：Prim 算法，Kruskal 算法

## Prim 算法

时间复杂度：e log v

## Prim 算法示例

## Kruskal 算法

时间复杂度：e log e

参见 CLRS/算法设计，J. Kleinberg, E. Tardos

## Kruskal 算法示例

## 下节课内容
- 课程复习

## 相关知识点总结
- [[图论与关系]] - 图论与关系知识分块总结
- [[离散数学总览]] - 离散数学整体概述
